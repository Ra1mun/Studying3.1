fprintf("Найти минимум функции одной переменной на заданном отрезке методами золотого сечения / парабол, реализованными в функции fminbnd\n")
% Определение функции
f = @(x) x.^3 - 7*x.^2 + 14*x - 8;

% Нахождение минимума на отрезке [2, 4] методом золотого сечения или парабол
[xmin, fmin] = fminbnd(f, 2, 4);

% Вывод результата
disp(['Минимум функции достигается в точке x = ', num2str(xmin)]);
disp(['Значение функции в этой точке: f(x) = ', num2str(fmin)]);

fprintf("Метода деформируемого многогранника Нелдера – Мида, реализованного в функции fminsearch\n")
% Определение функции f(x1, x2)
f = @(x) (1.5 - x(1) + x(1)*x(2))^2 + (2.25 - x(1) + x(1)*x(2)^2)^2 + (2.625 - x(1) + x(1)*x(2)^3)^2;

% Начальная точка для метода Нелдера-Мида
initial_guess = [0, 0];  % Можно выбрать любую точку в пределах [-4.5, 4.5]

% Минимизация функции с использованием fminsearch
[xmin, fmin] = fminsearch(f, initial_guess);

% Вывод результатов
disp(['Минимум функции достигается в точке x1 = ', num2str(xmin(1)), ' и x2 = ', num2str(xmin(2))]);
disp(['Значение функции в этой точке: f(x) = ', num2str(fmin)]);

fprintf("Метода Ньютона / квазиньютоновских методов, реализованных в функции fminunc\n")
% Определение функции f(x1, x2)
f = @(x) (1.5 - x(1) + x(1)*x(2))^2 + (2.25 - x(1) + x(1)*x(2)^2)^2 + (2.625 - x(1) + x(1)*x(2)^3)^2;

% Начальная точка для метода Ньютона или квазиньютоновских методов
initial_guess = [0, 0];  % Можно выбрать любую точку в пределах [-4.5, 4.5]

% Опции для fminunc, задаем метод и параметры
options = optimoptions('fminunc', 'Display', 'iter', 'Algorithm', 'quasi-newton');

% Минимизация функции с использованием fminunc
[xmin, fmin] = fminunc(f, initial_guess, options);

% Вывод результатов
disp(['Минимум функции достигается в точке x1 = ', num2str(xmin(1)), ' и x2 = ', num2str(xmin(2))]);
disp(['Значение функции в этой точке: f(x) = ', num2str(fmin)]);

fprintf("Найти минимум функции Била с указанными ограничениями методом последовательного квадратичного программирования, реализованного в функции fmincon\n")
% Определение функции f(x1, x2)
f = @(x) (1.5 - x(1) + x(1)*x(2))^2 + (2.25 - x(1) + x(1)*x(2)^2)^2 + (2.625 - x(1) + x(1)*x(2)^3)^2;

% Ограничения
% Ограничения в виде неравенств (Ax <= b)
A = [3, 0; -1, -2; 0, 1]; % Матрица A для неравенств
b = [55; -33; 3];          % Вектор b для неравенств

% Начальная точка
initial_guess = [1, 1];  % Можно выбрать любую точку, например [1, 1]

% Опции для fmincon, задаем метод SQP
options = optimoptions('fmincon', 'Display', 'iter', 'Algorithm', 'sqp');

% Минимизация функции с использованием fmincon
[xmin, fmin] = fmincon(f, initial_guess, A, b, [], [], [], [], [], options);

% Вывод результатов
disp(['Минимум функции достигается в точке x1 = ', num2str(xmin(1)), ' и x2 = ', num2str(xmin(2))]);
disp(['Значение функции в этой точке: f(x) = ', num2str(fmin)]);

fprintf("Обобщённого алгоритма поиска по образцу, реализованного в функции patternsearch\n")
fun = @(x) (1.5 - x(1) + x(1)*x(2))^2 + (2.25 - x(1) + x(1)*x(2)^2)^2 + (2.625 - x(1) + x(1)*x(2)^3)^2;

% Количество переменных
nvars = 2;

function [c, ceq] = nonlcon(x)
    c(1) = 3*x(1)^2 + 2*x(2)^3 - 55;       % c <= 0 (неравенство)
    c(2) = -(x(1)^3 + x(2)^2 - 33);        % c <= 0 (неравенство x1^3 + x2^2 >= 33)
    c(3) = x(1) - 2*x(2) - 3;              % c <= 0 (неравенство)
    ceq = [];                              % Нет равенств
end


% Начальная точка для поиска
x0 = [1, 1];

[x, fval] = patternsearch

% Вызов patternsearch с учетом нелинейных ограничений
[x, fval] = patternsearch(fun, nvars, [], [], [], [], [], [], @nonlcon);

% Вывод результата
fprintf('Оптимальное решение: x1 = %.4f, x2 = %.4f\n', x(1), x(2));
fprintf('Значение функции: f(x) = %.4f\n', fval);

fprintf("Генетических алгоритмов, реализованных в функции ga\n")

% Количество переменных
nvars = 2;  

% Вызов функции ga с нелинейными ограничениями
[x, fval] = ga(fun, nvars, [], [], [], [], [], [], @nonlcon);

% Вывод результата
fprintf('Оптимальное решение: x1 = %.4f, x2 = %.4f\n', x(1), x(2));
fprintf('Значение функции: f(x) = %.4f\n', fval);

